<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Burp Suite Traffic Visualizer Pro</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-dark: #0f172a;
            --bg-panel: #1e293b;
            --border: #334155;
            --text-primary: #f8fafc;
            --text-secondary: #94a3b8;
            --accent: #38bdf8;
            --accent-glow: rgba(56, 189, 248, 0.2);
            --method-get: #3b82f6;
            --method-post: #10b981;
            --method-put: #f59e0b;
            --method-delete: #ef4444;
            --node-host: #f472b6;
            --node-param: #a8a29e;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-dark);
            color: var(--text-primary);
            height: 100vh;
            overflow: hidden;
            display: flex;
        }

        /* Sidebar */
        aside {
            width: 340px;
            background: var(--bg-panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            z-index: 10;
            box-shadow: 4px 0 15px rgba(0,0,0,0.3);
            flex-shrink: 0;
        }

        .brand {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            font-size: 1.2rem;
            font-weight: 700;
            background: linear-gradient(to right, #38bdf8, #818cf8);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .controls {
            padding: 20px;
            overflow-y: auto;
            flex: 1;
        }

        .controls::-webkit-scrollbar { width: 6px; }
        .controls::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }

        /* Upload Area */
        .drop-zone {
            border: 2px dashed var(--border);
            border-radius: 8px;
            padding: 20px 16px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            background: rgba(255,255,255,0.02);
            margin-bottom: 24px;
        }

        .drop-zone:hover, .drop-zone.dragover {
            border-color: var(--accent);
            background: var(--accent-glow);
        }

        .drop-icon { font-size: 1.8rem; margin-bottom: 10px; display: block; }
        .drop-text { font-size: 0.85rem; color: var(--text-secondary); }

        /* Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
            margin-bottom: 24px;
        }

        .stat-box {
            background: rgba(0,0,0,0.2);
            padding: 10px;
            border-radius: 6px;
            text-align: center;
        }

        .stat-val { font-size: 1.1rem; font-weight: 700; color: var(--accent); }
        .stat-label { font-size: 0.65rem; color: var(--text-secondary); text-transform: uppercase; }

        /* Inputs */
        .control-group { margin-bottom: 20px; }
        .control-label { display: flex; justify-content: space-between; font-size: 0.85rem; margin-bottom: 8px; color: var(--text-secondary); font-weight: 500; }
        
        input[type="range"] {
            width: 100%;
            height: 4px;
            background: var(--border);
            border-radius: 2px;
            appearance: none;
            outline: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            transition: transform 0.1s;
        }

        /* Filter Inputs */
        .input-wrapper {
            position: relative;
            margin-bottom: 10px;
        }
        
        .filter-input {
            width: 100%;
            background: rgba(0,0,0,0.2);
            border: 1px solid var(--border);
            padding: 8px 12px;
            border-radius: 6px;
            color: var(--text-primary);
            font-family: 'Inter', sans-serif;
            font-size: 0.85rem;
            transition: border-color 0.2s;
        }
        
        .filter-input:focus { outline: none; border-color: var(--accent); }

        /* Method Toggles */
        .method-toggles {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 10px;
        }

        .method-btn {
            padding: 6px;
            border-radius: 4px;
            border: 1px solid var(--border);
            background: transparent;
            color: var(--text-secondary);
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }

        .method-btn.active { color: #fff; font-weight: 600; border: none; }
        .m-get.active { background: var(--method-get); }
        .m-post.active { background: var(--method-post); }
        .m-put.active { background: var(--method-put); }
        .m-del.active { background: var(--method-delete); }

        /* Buttons */
        .btn-group { display: flex; gap: 8px; margin-bottom: 12px; }
        
        .btn {
            flex: 1;
            padding: 8px;
            border: 1px solid var(--border);
            background: transparent;
            color: var(--text-secondary);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s;
        }

        .btn:hover { background: rgba(255,255,255,0.05); color: var(--text-primary); }
        .btn.active { background: var(--accent); color: #000; border-color: var(--accent); font-weight: 600; }

        .btn-reset {
            width: 100%;
            margin-top: 10px;
            padding: 8px;
            background: rgba(239, 68, 68, 0.1);
            color: #ef4444;
            border: 1px solid rgba(239, 68, 68, 0.2);
            border-radius: 6px;
            cursor: pointer;
        }
        .btn-reset:hover { background: rgba(239, 68, 68, 0.2); }

        .separator { height: 1px; background: var(--border); margin: 20px 0; }

        /* Main Canvas */
        main {
            flex: 1;
            position: relative;
            background: radial-gradient(circle at center, #1e293b 0%, #0f172a 100%);
            overflow: hidden;
        }

        #graph-container {
            width: 100%;
            height: 100%;
            cursor: move;
        }

        /* SVG Elements */
        .node circle { stroke: #fff; stroke-width: 1.5px; transition: all 0.3s; }
        .node:hover circle { stroke: var(--accent); stroke-width: 3px; filter: drop-shadow(0 0 8px var(--accent)); }
        .node text {
            font-family: 'Inter', sans-serif;
            font-size: 10px;
            fill: var(--text-primary);
            pointer-events: none;
            text-shadow: 0 1px 4px rgba(0,0,0,0.8);
        }
        .link { stroke: #475569; stroke-opacity: 0.4; transition: stroke-width 0.3s; }
        
        /* Legend */
        .legend {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(15, 23, 42, 0.9);
            backdrop-filter: blur(8px);
            padding: 12px;
            border-radius: 8px;
            border: 1px solid var(--border);
            font-size: 0.8rem;
            pointer-events: none;
        }
        .legend-item { display: flex; align-items: center; gap: 8px; margin-bottom: 4px; }
        .dot { width: 8px; height: 8px; border-radius: 50%; }

        /* Tooltip */
        #tooltip {
            position: absolute;
            opacity: 0;
            background: rgba(15, 23, 42, 0.95);
            border: 1px solid var(--border);
            padding: 12px;
            border-radius: 6px;
            pointer-events: none;
            max-width: 300px;
            z-index: 100;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
            transition: opacity 0.1s;
        }
        .tt-title { font-weight: 700; color: var(--accent); margin-bottom: 4px; border-bottom: 1px solid var(--border); padding-bottom: 4px; }
        .tt-row { display: flex; justify-content: space-between; gap: 12px; font-size: 0.8rem; margin-top: 4px; color: var(--text-secondary); }
        .tt-val { color: var(--text-primary); font-family: monospace; word-break: break-all; }

    </style>
</head>
<body>

<aside>
    <div class="brand">Burp Visualizer Pro</div>
    
    <div class="controls">
        <div class="drop-zone" id="dropZone">
            <span class="drop-icon">ðŸ“‚</span>
            <div class="drop-text">Drag & Drop Burp XML<br>or Click to Browse</div>
            <input type="file" id="fileInput" accept=".xml" hidden>
        </div>

        <div class="stats-grid">
            <div class="stat-box">
                <div class="stat-val" id="count-hosts">0</div>
                <div class="stat-label">Hosts</div>
            </div>
            <div class="stat-box">
                <div class="stat-val" id="count-reqs">0</div>
                <div class="stat-label">Reqs</div>
            </div>
            <div class="stat-box">
                <div class="stat-val" id="count-params">0</div>
                <div class="stat-label">Params</div>
            </div>
        </div>

        <div class="control-group">
            <div class="control-label">Layout</div>
            <div class="btn-group">
                <button class="btn active" onclick="app.setLayout('force', this)">Cluster</button>
                <button class="btn" onclick="app.setLayout('tree', this)">Tree</button>
                <button class="btn" onclick="app.setLayout('radial', this)">Radial</button>
            </div>
        </div>

        <div class="control-group">
            <div class="control-label">
                <span>Node Spacing</span>
                <span id="spacing-val">50</span>
            </div>
            <input type="range" id="spacingSlider" min="20" max="200" value="50">
        </div>

        <div class="separator"></div>

        <div class="control-group">
            <div class="control-label">FILTERS (AUTO-UPDATES)</div>
            
            <div class="input-wrapper">
                <input type="text" class="filter-input" id="filter-host" placeholder="Filter by Host..." oninput="app.applyFilters()">
            </div>

            <div class="input-wrapper">
                <input type="text" class="filter-input" id="filter-path" placeholder="Filter by Path..." oninput="app.applyFilters()">
            </div>

            <div class="control-label" style="font-size: 0.75rem; margin-top:10px;">HTTP Methods</div>
            <div class="method-toggles">
                <button class="method-btn m-get active" onclick="app.toggleMethod('GET', this)">GET</button>
                <button class="method-btn m-post active" onclick="app.toggleMethod('POST', this)">POST</button>
                <button class="method-btn m-put active" onclick="app.toggleMethod('PUT', this)">PUT</button>
                <button class="method-btn m-del active" onclick="app.toggleMethod('DELETE', this)">DELETE</button>
            </div>

            <div style="display: flex; gap: 8px;">
                <input type="text" class="filter-input" id="filter-status" placeholder="Status Code" oninput="app.applyFilters()">
                <input type="text" class="filter-input" id="filter-param" placeholder="Param Name" oninput="app.applyFilters()">
            </div>
            
            <button class="btn-reset" onclick="app.resetFilters()">Reset Filters</button>
        </div>
        
        <div class="separator"></div>
        <button class="btn" style="width:100%; border-color: var(--accent); color: var(--accent); background: rgba(56, 189, 248, 0.1);" onclick="app.autoFit(true)">
            ðŸŽ¯ Auto-Fit to Data
        </button>
    </div>
</aside>

<main>
    <div id="graph-container"></div>
    
    <div class="legend">
        <div class="legend-item"><div class="dot" style="background:var(--node-host)"></div>Host</div>
        <div class="legend-item"><div class="dot" style="background:var(--method-get)"></div>GET Request</div>
        <div class="legend-item"><div class="dot" style="background:var(--method-post)"></div>POST Request</div>
        <div class="legend-item"><div class="dot" style="background:var(--method-delete)"></div>DELETE/Other</div>
        <div class="legend-item"><div class="dot" style="background:var(--node-param)"></div>Parameter</div>
    </div>

    <div id="tooltip"></div>
</main>

<script>
class BurpVisualizer {
    constructor() {
        this.width = 0;
        this.height = 0;
        this.data = { nodes: [], links: [] };
        this.simulation = null;
        this.svg = null;
        this.g = null;
        this.zoom = null;
        this.layout = 'force'; 
        
        this.colors = {
            host: '#f472b6',
            param: '#a8a29e',
            GET: '#3b82f6',
            POST: '#10b981',
            PUT: '#f59e0b',
            DELETE: '#ef4444',
            default: '#64748b'
        };

        this.filters = {
            host: '',
            path: '',
            status: '',
            param: '',
            methods: new Set(['GET', 'POST', 'PUT', 'DELETE'])
        };

        this.init();
    }

    init() {
        const container = document.getElementById('graph-container');
        this.width = container.clientWidth;
        this.height = container.clientHeight;

        this.svg = d3.select('#graph-container').append('svg')
            .attr('width', '100%')
            .attr('height', '100%')
            .on('click', (e) => { if(e.target.tagName === 'svg') this.hideTooltip(); });

        this.svg.append('defs').append('marker')
            .attr('id', 'arrowhead')
            .attr('viewBox', '0 -5 10 10')
            .attr('refX', 22)
            .attr('refY', 0)
            .attr('orient', 'auto')
            .attr('markerWidth', 5)
            .attr('markerHeight', 5)
            .append('path')
            .attr('d', 'M0,-5L10,0L0,5')
            .attr('fill', '#475569')
            .style('opacity', 0.6);

        this.g = this.svg.append('g');

        this.zoom = d3.zoom()
            .scaleExtent([0.1, 8])
            .on('zoom', (event) => this.g.attr('transform', event.transform));

        this.svg.call(this.zoom);

        // Resize handler
        new ResizeObserver(() => {
            this.width = container.clientWidth;
            this.height = container.clientHeight;
            if(this.simulation) {
                this.simulation.force("center", d3.forceCenter(this.width / 2, this.height / 2));
                this.simulation.alpha(0.3).restart();
            }
        }).observe(container);

        this.setupUploadHandlers();
        
        document.getElementById('spacingSlider').addEventListener('input', (e) => {
            document.getElementById('spacing-val').innerText = e.target.value;
            this.updateForces();
        });
    }

    setupUploadHandlers() {
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');

        dropZone.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', (e) => this.handleFile(e.target.files[0]));

        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });

        dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            if (e.dataTransfer.files.length) this.handleFile(e.dataTransfer.files[0]);
        });
    }

    async handleFile(file) {
        if (!file || !file.name.endsWith('.xml')) {
            alert('Please upload a valid Burp Suite XML file.');
            return;
        }
        const text = await file.text();
        this.parseXML(text);
    }

    parseXML(xmlString) {
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(xmlString, "text/xml");
        
        if (xmlDoc.getElementsByTagName('parsererror').length) {
            alert('Error parsing XML. File might be corrupted.');
            return;
        }

        const items = xmlDoc.getElementsByTagName('item');
        const nodes = new Map();
        const links = [];
        let stats = { hosts: 0, reqs: 0, params: 0 };

        const getText = (parent, tag) => {
            const el = parent.getElementsByTagName(tag)[0];
            return el ? el.textContent : null;
        };

        Array.from(items).forEach(item => {
            const urlStr = getText(item, 'url');
            const host = getText(item, 'host');
            const method = getText(item, 'method') || 'GET';
            const status = getText(item, 'status') || '0';
            
            if (!urlStr || !host) return;

            // Host
            if (!nodes.has(host)) {
                nodes.set(host, { 
                    id: host, 
                    type: 'host', 
                    radius: 20, 
                    label: host,
                    data: { count: 0 },
                    // Init position at center to prevent explosion
                    x: this.width/2 + (Math.random() - 0.5) * 10,
                    y: this.height/2 + (Math.random() - 0.5) * 10
                });
                stats.hosts++;
            }
            nodes.get(host).data.count++;

            // Request
            try {
                const urlObj = new URL(urlStr);
                const path = urlObj.pathname;
                const reqId = `${method}|${host}${path}`;

                if (!nodes.has(reqId)) {
                    nodes.set(reqId, {
                        id: reqId,
                        type: 'request',
                        subtype: method,
                        radius: 12,
                        label: path,
                        data: { method, url: urlStr, status, host },
                        x: this.width/2,
                        y: this.height/2
                    });
                    stats.reqs++;
                    links.push({ source: host, target: reqId, type: 'host-req' });
                }

                // Params
                urlObj.searchParams.forEach((val, key) => {
                    const paramId = `${reqId}?${key}`;
                    if (!nodes.has(paramId)) {
                        nodes.set(paramId, {
                            id: paramId,
                            type: 'param',
                            radius: 6,
                            label: key,
                            data: { value: val, parentReq: reqId },
                            x: this.width/2,
                            y: this.height/2
                        });
                        stats.params++;
                        links.push({ source: reqId, target: paramId, type: 'req-param' });
                    }
                });
            } catch (e) {}
        });

        document.getElementById('count-hosts').innerText = stats.hosts;
        document.getElementById('count-reqs').innerText = stats.reqs;
        document.getElementById('count-params').innerText = stats.params;

        this.data = { nodes: Array.from(nodes.values()), links: links };
        this.updateGraph();
        
        // Auto fit after a delay to let layout settle
        setTimeout(() => this.autoFit(), 600);
    }

    toggleMethod(method, btn) {
        if (this.filters.methods.has(method)) {
            this.filters.methods.delete(method);
            btn.classList.remove('active');
        } else {
            this.filters.methods.add(method);
            btn.classList.add('active');
        }
        this.updateGraph();
    }

    applyFilters() {
        this.filters.host = document.getElementById('filter-host').value.toLowerCase();
        this.filters.path = document.getElementById('filter-path').value.toLowerCase();
        this.filters.status = document.getElementById('filter-status').value;
        this.filters.param = document.getElementById('filter-param').value.toLowerCase();
        this.updateGraph();
        setTimeout(() => this.autoFit(), 300);
    }

    resetFilters() {
        this.filters = {
            host: '', path: '', status: '', param: '',
            methods: new Set(['GET', 'POST', 'PUT', 'DELETE'])
        };
        ['filter-host','filter-path','filter-status','filter-param'].forEach(id => document.getElementById(id).value = '');
        document.querySelectorAll('.method-btn').forEach(btn => btn.classList.add('active'));
        this.updateGraph();
        setTimeout(() => this.autoFit(), 300);
    }

    getFilteredData() {
        const { host, path, status, param, methods } = this.filters;
        const visibleNodeIds = new Set();
        const requestNodeIds = new Set();
        const finalNodes = [];

        // 1. Identify Valid Requests
        this.data.nodes.forEach(n => {
            if (n.type === 'request') {
                const isMethodValid = methods.has(n.subtype) || (['GET','POST','PUT'].indexOf(n.subtype) === -1 && methods.has('DELETE'));
                const matchesHost = n.data.host.toLowerCase().includes(host);
                const matchesPath = n.label.toLowerCase().includes(path);
                const matchesStatus = n.data.status.includes(status);
                
                if (isMethodValid && matchesHost && matchesPath && matchesStatus) {
                    requestNodeIds.add(n.id);
                }
            }
        });

        // 2. Build visible set based on relationships
        this.data.nodes.forEach(n => {
            if (n.type === 'request') {
                if (requestNodeIds.has(n.id)) {
                    if(param === '') {
                        visibleNodeIds.add(n.id);
                        finalNodes.push(n);
                    }
                }
            }
            else if (n.type === 'param') {
                if (requestNodeIds.has(n.data.parentReq) && n.label.toLowerCase().includes(param)) {
                    visibleNodeIds.add(n.id);
                    visibleNodeIds.add(n.data.parentReq); // Force parent visible
                    finalNodes.push(n);
                }
            }
            else if (n.type === 'host') {
                // Keep hosts that have visible children or match text filter
                const hasVisibleChildren = Array.from(visibleNodeIds).some(id => id.includes(n.id));
                const nameMatches = n.label.toLowerCase().includes(host);
                if ((host !== '' && nameMatches) || hasVisibleChildren) {
                    visibleNodeIds.add(n.id);
                    finalNodes.push(n);
                }
            }
        });

        // 3. Re-add requests if they were enabled by param match
        if(param !== '') {
            this.data.nodes.forEach(n => {
                if(n.type === 'request' && visibleNodeIds.has(n.id) && !finalNodes.includes(n)) {
                    finalNodes.push(n);
                }
            });
        }

        const finalLinks = this.data.links.filter(l => 
            visibleNodeIds.has(typeof l.source === 'object' ? l.source.id : l.source) && 
            visibleNodeIds.has(typeof l.target === 'object' ? l.target.id : l.target)
        );

        return { nodes: finalNodes, links: finalLinks };
    }

    updateGraph() {
        if(this.simulation) this.simulation.stop();
        this.g.selectAll("*").remove();

        const filtered = this.getFilteredData();
        
        if (this.layout === 'force') {
            this.renderForceLayout(filtered.nodes, filtered.links);
        } else {
            this.renderHierarchicalLayout(filtered.nodes, filtered.links);
        }
    }

    renderForceLayout(nodes, links) {
        const spacing = parseInt(document.getElementById('spacingSlider').value);

        // Stronger gravity to center, stronger radial pull to keep them in a block
        this.simulation = d3.forceSimulation(nodes)
            .force("link", d3.forceLink(links).id(d => d.id).distance(l => l.type === 'host-req' ? spacing * 1.5 : spacing * 0.6))
            .force("charge", d3.forceManyBody().strength(-300)) // Strong repulsion for spacing
            .force("collide", d3.forceCollide().radius(d => d.radius * 1.4))
            .force("center", d3.forceCenter(this.width / 2, this.height / 2))
            // This is the magic force that keeps them in a "block"/cluster
            .force("radial", d3.forceRadial(100, this.width/2, this.height/2).strength(0.8));

        this.drawElements(nodes, links);

        this.simulation.on("tick", () => {
            this.g.selectAll(".link")
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y);

            this.g.selectAll(".node")
                .attr("transform", d => `translate(${d.x},${d.y})`);
        });
    }

    renderHierarchicalLayout(nodes, links) {
        if(nodes.length === 0) return;

        const forest = { id: "ROOT", children: [] };
        const hostMap = new Map();
        
        nodes.filter(n => n.type === 'host').forEach(h => {
            h.children = [];
            hostMap.set(h.id, h);
            forest.children.push(h);
        });

        const reqMap = new Map();
        nodes.filter(n => n.type === 'request').forEach(req => {
            req.children = [];
            reqMap.set(req.id, req);
            const parent = hostMap.get(req.data.host);
            if(parent) parent.children.push(req);
            else forest.children.push(req);
        });

        nodes.filter(n => n.type === 'param').forEach(param => {
            const parent = reqMap.get(param.data.parentReq);
            if(parent) parent.children.push(param);
        });

        const root = d3.hierarchy(forest);
        const spacing = parseInt(document.getElementById('spacingSlider').value);
        
        let treeLayout;
        if (this.layout === 'radial') {
            const radius = Math.min(this.width, this.height) / 2 * 0.8;
            treeLayout = d3.tree().size([2 * Math.PI, radius]).separation((a, b) => (a.parent == b.parent ? 1 : 2) / a.depth);
        } else {
            // Tighter vertical layout
            treeLayout = d3.tree().size([this.height, this.width - 250]).nodeSize([25, spacing * 3]);
        }

        treeLayout(root);
        const computedNodes = root.descendants().slice(1);
        const computedLinks = root.links().filter(l => l.source.data.id !== 'ROOT');

        if (this.layout === 'radial') {
            computedNodes.forEach(d => {
                d.x = d.y * Math.cos(d.x - Math.PI / 2) + this.width / 2;
                d.y = d.y * Math.sin(d.x - Math.PI / 2) + this.height / 2;
                d.data.x = d.x; d.data.y = d.y;
            });
        } else {
            computedNodes.forEach(d => {
                const temp = d.x;
                d.x = d.y + 100; // Left padding
                d.y = temp + this.height/2; 
                d.data.x = d.x; d.data.y = d.y;
            });
        }

        const renderLinks = computedLinks.map(l => ({ source: l.source.data, target: l.target.data, type: l.target.data.type === 'param' ? 'req-param' : 'host-req' }));
        const renderNodes = computedNodes.map(n => n.data);
        
        this.drawElements(renderNodes, renderLinks);
        
        this.g.selectAll(".link")
            .attr("x1", d => d.source.x)
            .attr("y1", d => d.source.y)
            .attr("x2", d => d.target.x)
            .attr("y2", d => d.target.y);

        this.g.selectAll(".node")
            .attr("transform", d => `translate(${d.x},${d.y})`);
        
        // Auto fit tree layouts immediately
        this.autoFit(true);
    }

    drawElements(nodes, links) {
        const linkElements = this.g.selectAll(".link")
            .data(links)
            .enter().append("line")
            .attr("class", "link")
            .attr("marker-end", d => d.type === 'host-req' ? "url(#arrowhead)" : "")
            .attr("stroke-width", d => d.type === 'host-req' ? 2 : 1);

        const nodeElements = this.g.selectAll(".node")
            .data(nodes)
            .enter().append("g")
            .attr("class", "node")
            .call(d3.drag()
                .on("start", (event, d) => {
                    if(this.layout !== 'force') return;
                    if (!event.active) this.simulation.alphaTarget(0.3).restart();
                    d.fx = d.x;
                    d.fy = d.y;
                })
                .on("drag", (event, d) => {
                    if(this.layout !== 'force') return;
                    d.fx = event.x;
                    d.fy = event.y;
                })
                .on("end", (event, d) => {
                    if(this.layout !== 'force') return;
                    if (!event.active) this.simulation.alphaTarget(0);
                    d.fx = null;
                    d.fy = null;
                })
            )
            .on("mouseover", (e, d) => this.showTooltip(e, d))
            .on("mouseout", () => this.hideTooltip());

        nodeElements.append("circle")
            .attr("r", d => d.radius)
            .attr("fill", d => {
                if (d.type === 'host') return this.colors.host;
                if (d.type === 'param') return this.colors.param;
                return this.colors[d.subtype] || this.colors.default;
            });

        nodeElements.append("text")
            .attr("dx", d => d.radius + 5)
            .attr("dy", 4)
            .text(d => d.type === 'param' ? '' : (d.label.length > 25 ? d.label.substring(0, 22) + '...' : d.label));
    }

    updateForces() {
        if (this.simulation) {
            const spacing = parseInt(document.getElementById('spacingSlider').value);
            this.simulation.force("link").distance(l => l.type === 'host-req' ? spacing * 1.5 : spacing * 0.6);
            this.simulation.alpha(0.3).restart();
        } else if (this.layout !== 'force') {
            this.updateGraph();
        }
    }

    setLayout(mode, btn) {
        this.layout = mode;
        const group = btn.parentElement;
        group.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        this.updateGraph();
        
        // Hide/Show Spacing slider based on layout
        // Tree layout doesn't use physics spacing the same way, but we kept it for nodeSize
    }

    // --- KEY FEATURE: AUTO FIT ---
    autoFit(animate = true) {
        // Calculate Bounding Box of the Group
        const bounds = this.g.node().getBBox();
        const parent = this.svg.node().parentElement;
        const fullWidth = parent.clientWidth;
        const fullHeight = parent.clientHeight;
        
        const width = bounds.width;
        const height = bounds.height;
        const midX = bounds.x + width / 2;
        const midY = bounds.y + height / 2;

        if (width === 0 || height === 0) return; // Empty

        const scale = 0.85 / Math.max(width / fullWidth, height / fullHeight);
        const translate = [fullWidth / 2 - scale * midX, fullHeight / 2 - scale * midY];

        const t = d3.zoomIdentity
            .translate(translate[0], translate[1])
            .scale(scale);

        if(animate) {
            this.svg.transition().duration(750).call(this.zoom.transform, t);
        } else {
            this.svg.call(this.zoom.transform, t);
        }
    }

    showTooltip(event, d) {
        const tooltip = document.getElementById('tooltip');
        let content = `<div class="tt-title">${d.type.toUpperCase()}</div>`;
        
        if (d.type === 'host') {
            content += `
                <div class="tt-row"><span>Host:</span> <span class="tt-val">${d.id}</span></div>
                <div class="tt-row"><span>Reqs:</span> <span class="tt-val">${d.data.count}</span></div>
            `;
        } else if (d.type === 'request') {
            content += `
                <div class="tt-row"><span>Method:</span> <span class="tt-val" style="color:${this.colors[d.subtype]}">${d.subtype}</span></div>
                <div class="tt-row"><span>Path:</span> <span class="tt-val">${d.label}</span></div>
                <div class="tt-row"><span>Status:</span> <span class="tt-val">${d.data.status}</span></div>
            `;
        } else if (d.type === 'param') {
            content += `
                <div class="tt-row"><span>Param:</span> <span class="tt-val">${d.label}</span></div>
                <div class="tt-row"><span>Value:</span> <span class="tt-val">${d.data.value}</span></div>
            `;
        }

        tooltip.innerHTML = content;
        tooltip.style.opacity = 1;
        tooltip.style.left = (event.pageX + 15) + 'px';
        tooltip.style.top = (event.pageY + 15) + 'px';
    }

    hideTooltip() {
        document.getElementById('tooltip').style.opacity = 0;
    }
}

const app = new BurpVisualizer();
</script>

</body>
</html>
